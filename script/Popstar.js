/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./script/Popstar.es6":
/*!****************************!*\
  !*** ./script/Popstar.es6 ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \t@ author: leeenx\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \t@ 消除星星\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\n// 向前兼容\n//import 'babel-polyfill'; \n\nvar _Model = __webpack_require__(/*! ./core/Model.es6 */ \"./script/core/Model.es6\");\n\nvar _Model2 = _interopRequireDefault(_Model);\n\nvar _View = __webpack_require__(/*! ./core/View.es6 */ \"./script/core/View.es6\");\n\nvar _View2 = _interopRequireDefault(_View);\n\nvar _Control = __webpack_require__(/*! ./core/Control.es6 */ \"./script/core/Control.es6\");\n\nvar _Control2 = _interopRequireDefault(_Control);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Popstar = function () {\n\tfunction Popstar(config) {\n\t\tvar _this = this;\n\n\t\t_classCallCheck(this, Popstar);\n\n\t\t// mvc 初始化\n\t\tthis.model = new _Model2.default();\n\t\tthis.view = new _View2.default(config.view);\n\t\t// mv 由于 c 控制\n\t\tthis.constrol = new _Control2.default(this.model, this.view, config.total);\n\t\t// 挂载 event\n\t\tthis.event = this.constrol.event;\n\t\t// 总得分\n\t\tReflect.defineProperty(this, \"total\", {\n\t\t\tget: function get() {\n\t\t\t\treturn _this.constrol.total;\n\t\t\t},\n\t\t\tset: function set(value) {\n\t\t\t\treturn _this.constrol.total = value;\n\t\t\t}\n\t\t});\n\t\t// 当前关卡 ---- 只读\n\t\tReflect.defineProperty(this, \"level\", {\n\t\t\tget: function get() {\n\t\t\t\treturn _this.constrol.curLevel;\n\t\t\t}\n\t\t});\n\t}\n\t// 开始游戏\n\n\n\t_createClass(Popstar, [{\n\t\tkey: 'enter',\n\t\tvalue: function enter(level) {\n\t\t\tthis.constrol.enter(level);\n\t\t}\n\t\t// 下一关\n\n\t}, {\n\t\tkey: 'next',\n\t\tvalue: function next() {\n\t\t\tthis.constrol.next();\n\t\t}\n\t\t// 暂停\n\n\t}, {\n\t\tkey: 'pause',\n\t\tvalue: function pause() {\n\t\t\tthis.constrol.pause();\n\t\t}\n\t\t// 恢复\n\n\t}, {\n\t\tkey: 'resume',\n\t\tvalue: function resume() {\n\t\t\tthis.constrol.resume();\n\t\t}\n\t\t// 销毁\n\n\t}, {\n\t\tkey: 'destroy',\n\t\tvalue: function destroy() {\n\t\t\tthis.constrol.destroy();\n\t\t}\n\t}]);\n\n\treturn Popstar;\n}();\n\nwindow.Popstar = Popstar;\n\n//# sourceURL=webpack:///./script/Popstar.es6?");

/***/ }),

/***/ "./script/core/Control.es6":
/*!*********************************!*\
  !*** ./script/core/Control.es6 ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Event = __webpack_require__(/*! ../lib/Event.es6 */ \"./script/lib/Event.es6\");\n\nvar _Event2 = _interopRequireDefault(_Event);\n\nvar _timer = __webpack_require__(/*! ../lib/timer.es6 */ \"./script/lib/timer.es6\");\n\nvar _timer2 = _interopRequireDefault(_timer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Constrol = function () {\n\tfunction Constrol(model, view) {\n\t\tvar _this = this;\n\n\t\tvar total = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n\t\t_classCallCheck(this, Constrol);\n\n\t\tthis.model = model, this.view = view;\n\n\t\t// event 事件\n\t\tthis.event = new _Event2.default();\n\n\t\t// view 与 control 共享一个event\n\t\tthis.view.event = this.event;\n\n\t\t// 当前总分\n\t\tReflect.defineProperty(this, \"total\", {\n\t\t\tget: function get() {\n\t\t\t\treturn _this.view.total;\n\t\t\t},\n\t\t\tset: function set(value) {\n\t\t\t\treturn _this.view.total = value;\n\t\t\t}\n\t\t});\n\n\t\t// view 与 control 共享一个 timer\n\t\tthis.view.timer = _timer2.default;\n\n\t\t// 当前关卡\n\t\tObject.defineProperties(this, {\n\t\t\t\"curLevel\": {\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn _this._curLevel || 0;\n\t\t\t\t},\n\t\t\t\tset: function set(value) {\n\t\t\t\t\t_this._curLevel = value || 0;\n\t\t\t\t\t_this.view.setLevel(_this._curLevel + 1);\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"goal\": {\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn _this._goal || 0;\n\t\t\t\t},\n\t\t\t\tset: function set(value) {\n\t\t\t\t\t_this._goal = value || 0;\n\t\t\t\t\t_this.view.setGoal(value);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// 数据绑定: model.tiles -> view.tiles\n\t\tmodel.tiles.forEach(function (tile) {\n\t\t\tReflect.defineProperty(tile, \"index\", {\n\t\t\t\tset: function set(value) {\n\t\t\t\t\tif (value === tile._index) return false;\n\t\t\t\t\tReflect.set(tile, \"_index\", value);\n\t\t\t\t\t// 与view同步数据\n\t\t\t\t\tview.update(tile);\n\t\t\t\t},\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn Reflect.get(tile, \"_index\");\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tReflect.defineProperty(tile, \"clr\", {\n\t\t\t\tset: function set(value) {\n\t\t\t\t\tif (value === tile._clr) return false;\n\t\t\t\t\tReflect.set(tile, \"_clr\", value);\n\t\t\t\t\t// 与view同步数据\n\t\t\t\t\tview.update(tile);\n\t\t\t\t},\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn Reflect.get(tile, \"_clr\");\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tReflect.defineProperty(tile, \"removed\", {\n\t\t\t\tset: function set(value) {\n\t\t\t\t\tif (value === tile._removed) return false;\n\t\t\t\t\tReflect.set(tile, \"_removed\", value);\n\t\t\t\t\t// 与view同步数据\n\t\t\t\t\tview.update(tile);\n\t\t\t\t},\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn Reflect.get(tile, \"_removed\") || false;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\t// 当前分数\n\t\tthis.total = total;\n\n\t\t// 监听点击事件\n\t\tthis.event.on(\"view-tap\", function (index) {\n\t\t\t// 暂停状态下锁屏\n\t\t\tif (_this.paused === true) return;\n\t\t\t// 消除 model 的砖块\n\t\t\tvar count = _this.model.clean(index);\n\t\t\t// 显示边消信息\n\t\t\tcount > 0 && _this.view.setCleanInfo(count);\n\t\t});\n\n\t\t// 清除相邻的同色砖事件\n\t\tthis.event.on(\"view-clean\", function () {\n\t\t\t// 结束压缩数组\n\t\t\t_this.model.tamp();\n\t\t\t// 游戏进入死局 ---- 清空剩余的色砖\n\t\t\tif (_this.model.check() === false) {\n\t\t\t\t_this.view.showBountyInfo(_this.model.tileCount).then(\n\t\t\t\t// 显示清空色砖，并计算奖励分数 \n\t\t\t\tfunction () {\n\t\t\t\t\treturn _this.model.cleanAll();\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\t// 清空所有的色砖事件\n\t\tthis.event.on(\"view-clean-all\", function () {\n\t\t\tif (_this.total < _this.goal) {\n\t\t\t\t// 游戏结束\n\t\t\t\t_this.event.dispatch(\"gameover\");\n\t\t\t}\n\t\t\t// 通关\n\t\t\telse {\n\t\t\t\t\t_this.event.dispatch(\"pass\");\n\t\t\t\t}\n\t\t});\n\t\t// 按下暂停按钮\n\t\tthis.event.on(\"view-press-pause\", function () {\n\t\t\t// this.pause(); \n\t\t\t_this.event.dispatch(\"pause\");\n\t\t});\n\t\t// 按下播放按钮\n\t\tthis.event.on(\"view-press-play\", function () {\n\t\t\t// this.resume(); \n\t\t\t_this.event.dispatch(\"resume\");\n\t\t});\n\n\t\tthis.init = this.init.bind(this);\n\t\tthis.destroy = this.destroy.bind(this);\n\t\tthis.enter = this.enter.bind(this);\n\t\tthis.next = this.next.bind(this);\n\t\tthis.pause = this.pause.bind(this);\n\t\tthis.resume = this.resume.bind(this);\n\t}\n\t// 初关卡\n\n\n\t_createClass(Constrol, [{\n\t\tkey: 'init',\n\t\tvalue: function init() {\n\t\t\t// 默认五个颜色\n\t\t\tthis.model.init();\n\t\t\t// 砖块动画\n\t\t\tthis.view.init();\n\t\t}\n\t\t// 销毁 \n\n\t}, {\n\t\tkey: 'destroy',\n\t\tvalue: function destroy() {\n\t\t\tthis.view.destroy();\n\t\t\t// 总分数清空\n\t\t\tthis.total = 0;\n\t\t}\n\t\t// 指定关数\n\n\t}, {\n\t\tkey: 'enter',\n\t\tvalue: function enter() {\n\t\t\tvar level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n\t\t\tthis.curLevel = level || 0;\n\t\t\t// 目标分数\n\t\t\tthis.goal = level * 2000 + 1000;\n\t\t\t// 初始化关卡\n\t\t\tthis.init();\n\t\t}\n\t\t// 下一关\n\n\t}, {\n\t\tkey: 'next',\n\t\tvalue: function next() {\n\t\t\tthis.enter(this.curLevel + 1);\n\t\t}\n\t\t// 暂停游戏\n\n\t}, {\n\t\tkey: 'pause',\n\t\tvalue: function pause() {\n\t\t\t// 暂停计时\n\t\t\t_timer2.default.pause();\n\t\t\t// 暂停渲染\n\t\t\tthis.view.pause();\n\t\t\t// 标记暂停\n\t\t\tthis.paused = true;\n\t\t}\n\t\t// 恢复游戏\n\n\t}, {\n\t\tkey: 'resume',\n\t\tvalue: function resume() {\n\t\t\t// 恢复计时\n\t\t\t_timer2.default.resume();\n\t\t\t// 恢复渲染\n\t\t\tthis.view.resume();\n\t\t\t// 标记恢复\n\t\t\tthis.paused = false;\n\t\t}\n\t}]);\n\n\treturn Constrol;\n}();\n\nexports.default = Constrol;\n\n//# sourceURL=webpack:///./script/core/Control.es6?");

/***/ }),

/***/ "./script/core/Model.es6":
/*!*******************************!*\
  !*** ./script/core/Model.es6 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \t@ author: leeenx\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \t@ 模式\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\nvar _shuffle = __webpack_require__(/*! ../lib/shuffle.es6 */ \"./script/lib/shuffle.es6\");\n\nvar _shuffle2 = _interopRequireDefault(_shuffle);\n\nvar _waveaverage = __webpack_require__(/*! ../lib/waveaverage.es6 */ \"./script/lib/waveaverage.es6\");\n\nvar _waveaverage2 = _interopRequireDefault(_waveaverage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Model = function () {\n\tfunction Model() {\n\t\t_classCallCheck(this, Model);\n\n\t\t// 行列数 - 固定\n\t\tthis.row = this.col = 10;\n\t\t/* \n  \t@ 墙体信息 - 因为砖块是向下沉的 \n  \t@ count - 列砖块数\n  \t@ start - 顶部行索引\n  \t@ end - 底部行索引(好像没什么意思，因为它是个固定值)\n  \t@ pitCount - 坑数\n  \t@ topPit - 最顶部的坑\n  \t@ bottomPit - 最底部的坑\n  \t@ 如果 pitCount > 0 && bottomPit - topPit + 1 === pitCount 表示坑位是连续的 \n  */\n\t\tthis.wall = new Array(this.col);\n\t\tfor (var i = 0; i < this.col; ++i) {\n\t\t\tthis.wall[i] = {\n\t\t\t\tcount: this.row,\n\t\t\t\tstart: 0,\n\t\t\t\tend: this.row - 1,\n\t\t\t\tpitCount: 0,\n\t\t\t\ttopPit: this.row,\n\t\t\t\tbottomPit: -1\n\t\t\t};\n\t\t}\n\n\t\t// 需要更新的列 - 记录哪几个列被消除了砖块\n\t\tthis.updatedColSet = new Set();\n\n\t\t// 表格总数 10x10\n\t\tthis.gridCellCount = 100;\n\n\t\t// 星星的表格\n\t\tthis.grid = [];\n\n\t\t// 砖块\n\t\tthis.tiles = new Array(this.gridCellCount);\n\t\tfor (var _i = 0; _i < this.gridCellCount; ++_i) {\n\t\t\tthis.tiles[_i] = {\n\t\t\t\t// 原始索引 ---- 永远不变（相当于id）\n\t\t\t\toriginIndex: undefined,\n\t\t\t\t// 实时索引 ---- 反映在 grid 的位置\n\t\t\t\tindex: undefined,\n\t\t\t\t// 颜色索引\n\t\t\t\tclr: 0,\n\t\t\t\t// 分值\n\t\t\t\tscore: 0,\n\t\t\t\t// 是否移除 \n\t\t\t\tremoved: false\n\t\t\t};\n\t\t}\n\n\t\t// 可见色砖总数\n\t\tthis.tileCount = this.gridCellCount;\n\t\tthis.init = this.init.bind(this);\n\t\tthis.compareTopTile = this.compareTopTile.bind(this);\n\t\tthis.incompareRightTileit = this.compareRightTile.bind(this);\n\t\tthis.compareBottomTile = this.compareBottomTile.bind(this);\n\t\tthis.compareLeftTile = this.compareLeftTile.bind(this);\n\t\tthis.hasNeighbour = this.hasNeighbour.bind(this);\n\t\tthis.searchSameClr = this.searchSameClr.bind(this);\n\t\tthis.deleteCell = this.deleteCell.bind(this);\n\t\tthis.clean = this.clean.bind(this);\n\t\tthis.cleanAll = this.cleanAll.bind(this);\n\t\tthis.updateColInfo = this.updateColInfo.bind(this);\n\t\tthis.tamp = this.tamp.bind(this);\n\t\tthis.check = this.check.bind(this);\n\t}\n\t// 填充数组 ---- count 表示几种颜色\n\n\n\t_createClass(Model, [{\n\t\tkey: 'init',\n\t\tvalue: function init() {\n\t\t\tvar _this = this;\n\n\t\t\t// 色砖小计数\n\t\t\tvar subtotal = 0;\n\t\t\t// 波动均分色块\n\t\t\t(0, _waveaverage2.default)(5, 4, 4).forEach(function (count, clr) {\n\t\t\t\tcount += 20;\n\t\t\t\t// 色砖数量 \n\t\t\t\twhile (0 < count--) {\n\t\t\t\t\tvar tile = _this.tiles[subtotal++];\n\t\t\t\t\t// 删除 originIndex ---- 提前删除可以提升性能\n\t\t\t\t\tdelete tile.originIndex;\n\t\t\t\t\ttile.clr = clr;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// 打散 tiles\n\t\t\t(0, _shuffle2.default)(this.tiles);\n\n\t\t\t// 存入 grid\n\t\t\tthis.grid = this.tiles.map(function (tile, index) {\n\t\t\t\t// 实时索引\n\t\t\t\ttile.index = index;\n\t\t\t\t// 原索引\n\t\t\t\ttile.originIndex = index;\n\t\t\t\t// 默认在舞台上 \n\t\t\t\ttile.removed = false;\n\t\t\t\treturn tile;\n\t\t\t});\n\n\t\t\t// 可见色砖总数重置 \n\t\t\tthis.tileCount = this.gridCellCount;\n\n\t\t\t// 生成新的列信息\n\t\t\tfor (var i = 0; i < this.col; ++i) {\n\t\t\t\tthis.wall[i] = {\n\t\t\t\t\tcount: this.row,\n\t\t\t\t\tstart: 0,\n\t\t\t\t\tend: this.row - 1,\n\t\t\t\t\tpitCount: 0,\n\t\t\t\t\ttopPit: this.row,\n\t\t\t\t\tbottomPit: -1\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// 死局 ---- 重新生成关卡\n\t\t\tif (this.check() === false) {\n\t\t\t\tthis.init();\n\t\t\t}\n\t\t}\n\t\t// 上节点颜色对比\n\n\t}, {\n\t\tkey: 'compareTopTile',\n\t\tvalue: function compareTopTile(index, rowIndex, colIndex, clr) {\n\t\t\t// 上节点索引\n\t\t\tvar topIndex = index - this.col;\n\t\t\t// 上边界「行」索引\n\t\t\tvar topBoundary = this.wall[colIndex].start;\n\t\t\t// 在最顶部\n\t\t\tif (rowIndex === topBoundary) return false;\n\t\t\t// 非最顶部\n\t\t\telse if (this.grid[topIndex] !== undefined && this.grid[topIndex].clr === clr) {\n\t\t\t\t\treturn topIndex;\n\t\t\t\t}\n\t\t\t\t// 颜色不匹配\n\t\t\t\telse {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t}\n\t\t// 右节点颜色对比\n\n\t}, {\n\t\tkey: 'compareRightTile',\n\t\tvalue: function compareRightTile(index, rowIndex, colIndex, clr) {\n\t\t\t// 右节点索引\n\t\t\tvar rightIndex = index + 1;\n\t\t\t// 右边界「列」索引 \n\t\t\tvar rightBoundary = this.wall.length - 1;\n\t\t\t// 在最右部\n\t\t\tif (colIndex === rightBoundary) return false;\n\t\t\t// 非最右部\n\t\t\telse if (this.grid[rightIndex] !== undefined && this.grid[rightIndex].clr === clr) {\n\t\t\t\t\treturn rightIndex;\n\t\t\t\t}\n\t\t\t\t// 颜色不匹配\n\t\t\t\telse {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t}\n\t\t// 下节点颜色对比\n\n\t}, {\n\t\tkey: 'compareBottomTile',\n\t\tvalue: function compareBottomTile(index, rowIndex, colIndex, clr) {\n\t\t\t// 下节点索引\n\t\t\tvar bottomIndex = index + this.col;\n\t\t\t// 下边界「行」索引\n\t\t\tvar bottomBoundary = this.wall[colIndex].end;\n\t\t\t// 在最底部\n\t\t\tif (rowIndex === bottomBoundary) return false;\n\t\t\t// 非最底部\n\t\t\telse if (this.grid[bottomIndex] !== undefined && this.grid[bottomIndex].clr === clr) {\n\t\t\t\t\treturn bottomIndex;\n\t\t\t\t}\n\t\t\t\t// 颜色不匹配\n\t\t\t\telse {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t}\n\t\t// 左节点颜色对比\n\n\t}, {\n\t\tkey: 'compareLeftTile',\n\t\tvalue: function compareLeftTile(index, rowIndex, colIndex, clr) {\n\t\t\t// 左节点索引\n\t\t\tvar leftIndex = index - 1;\n\t\t\t// 右边界「列」索引\n\t\t\tvar leftBoundary = 0;\n\t\t\t// 在最左部\n\t\t\tif (colIndex === leftBoundary) return false;\n\t\t\t// 非最左部\n\t\t\telse if (this.grid[leftIndex] !== undefined && this.grid[leftIndex].clr === clr) {\n\t\t\t\t\treturn leftIndex;\n\t\t\t\t}\n\t\t\t\t// 颜色不匹配\n\t\t\t\telse {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t}\n\t\t// 检查是否存在相邻的同色砖块\n\n\t}, {\n\t\tkey: 'hasNeighbour',\n\t\tvalue: function hasNeighbour(index, rowIndex, colIndex) {\n\t\t\tvar tile = this.grid[index];\n\t\t\tif (tile === undefined) return false;\n\t\t\tvar clr = tile.clr;\n\t\t\tif (this.compareTopTile(index, rowIndex, colIndex, clr) !== false) return true;else if (this.compareRightTile(index, rowIndex, colIndex, clr) !== false) return true;else if (this.compareBottomTile(index, rowIndex, colIndex, clr) !== false) return true;else if (this.compareLeftTile(index, rowIndex, colIndex, clr) !== false) return true;else return false;\n\t\t}\n\t\t// 寻找相邻同色砖块\n\n\t}, {\n\t\tkey: 'searchSameClr',\n\t\tvalue: function searchSameClr(index, rowIndex, colIndex, clr) {\n\t\t\tvar sameClrTiles = [this.compareTopTile(index, rowIndex, colIndex, clr), this.compareRightTile(index, rowIndex, colIndex, clr), this.compareBottomTile(index, rowIndex, colIndex, clr), this.compareLeftTile(index, rowIndex, colIndex, clr)];\n\t\t\treturn sameClrTiles.filter(function (index) {\n\t\t\t\treturn index !== false;\n\t\t\t});\n\t\t}\n\t\t// 删除指字的单元格\n\n\t}, {\n\t\tkey: 'deleteCell',\n\t\tvalue: function deleteCell(index, rowIndex, colIndex, count) {\n\t\t\tvar tile = this.grid[index];\n\t\t\t// 表示已经被删除过了\n\t\t\tif (tile === undefined) return false;\n\t\t\t// 标记分值\n\t\t\ttile.score = count * 10 + 5;\n\t\t\t// 标记被移去\n\t\t\ttile.removed = true;\n\t\t\t// 从 grid 上删除 \n\t\t\tdelete this.grid[index];\n\t\t\t// 更新colInfo\n\t\t\tthis.updateColInfo(index, rowIndex, colIndex);\n\t\t\treturn true;\n\t\t}\n\t\t// 清除指定索引的色块及其相邻的同色块\n\n\t}, {\n\t\tkey: 'clean',\n\t\tvalue: function clean(index) {\n\t\t\tvar _this2 = this;\n\n\t\t\t// 当前的行列坐标 - 纯粹是为了提高一点性能\n\t\t\tvar colIndex = index % this.col,\n\t\t\t    rowIndex = index / this.col >> 0;\n\t\t\t// 周边没有相同颜色砖块，直接中断\n\t\t\tif (this.hasNeighbour(index, rowIndex, colIndex) === false) return 0;\n\t\t\t// 周边有相同颜色砖块\n\t\t\telse {\n\t\t\t\t\tvar _ret = function () {\n\t\t\t\t\t\t// 当前砖块\n\t\t\t\t\t\tvar tile = _this2.grid[index],\n\t\t\t\t\t\t    clr = tile.clr;\n\n\t\t\t\t\t\t// 同色砖块\n\t\t\t\t\t\tvar sameClrTiles = _this2.searchSameClr(index, rowIndex, colIndex, clr);\n\n\t\t\t\t\t\t// 被删除的个数\n\t\t\t\t\t\tvar count = 0;\n\n\t\t\t\t\t\t// 删除砖块\n\t\t\t\t\t\t_this2.deleteCell(index, rowIndex, colIndex, count) && ++count;\n\n\t\t\t\t\t\tvar _loop = function _loop() {\n\t\t\t\t\t\t\t// 下一次循环的 sameClrTiles 数组\n\t\t\t\t\t\t\tvar nextSameClrTiles = [];\n\t\t\t\t\t\t\tsameClrTiles.forEach(function (index) {\n\t\t\t\t\t\t\t\t// 当前的行列坐标 - 纯粹是为了提高一点性能\n\t\t\t\t\t\t\t\tvar colIndex = index % _this2.col,\n\t\t\t\t\t\t\t\t    rowIndex = index / _this2.col >> 0;\n\t\t\t\t\t\t\t\tnextSameClrTiles.push.apply(nextSameClrTiles, _toConsumableArray(_this2.searchSameClr(index, rowIndex, colIndex, clr)));\n\t\t\t\t\t\t\t\t_this2.deleteCell(index, rowIndex, colIndex, count) && ++count;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t// 下一次的同色砖块数量为0，表示清除结束\n\t\t\t\t\t\t\tif (nextSameClrTiles.length === 0) return 'break';\n\t\t\t\t\t\t\t// 数组替换\n\t\t\t\t\t\t\tsameClrTiles = nextSameClrTiles;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tvar _ret2 = _loop();\n\n\t\t\t\t\t\t\tif (_ret2 === 'break') break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 夯实数组\n\t\t\t\t\t\t// this.tamp(); \n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tv: count\n\t\t\t\t\t\t};\n\t\t\t\t\t}();\n\n\t\t\t\t\tif ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t\t\t\t}\n\t\t}\n\t\t// 清空所有的色砖\n\n\t}, {\n\t\tkey: 'cleanAll',\n\t\tvalue: function cleanAll() {\n\t\t\t// 减分倍数\n\t\t\tvar count = 0;\n\t\t\tfor (var col = 0, len = this.wall.length; col < len; ++col) {\n\t\t\t\tvar colInfo = this.wall[col];\n\t\t\t\tfor (var row = colInfo.start; row <= colInfo.end; ++row) {\n\t\t\t\t\tvar tile = this.grid[row * this.col + col];\n\t\t\t\t\ttile.score = -20 - 40 * count++;\n\t\t\t\t\ttile.removed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 更新列信息\n\n\t}, {\n\t\tkey: 'updateColInfo',\n\t\tvalue: function updateColInfo(index, rowIndex, colIndex) {\n\t\t\tthis.updatedColSet.has(colIndex) || this.updatedColSet.add(colIndex);\n\t\t\tvar colInfo = this.wall[colIndex];\n\t\t\t// 当前列砖块数量减1\n\t\t\t--colInfo.count;\n\t\t\t// 列的空洞数加1\n\t\t\t++colInfo.pitCount;\n\t\t\t// 更新顶坑位置\n\t\t\tcolInfo.topPit = Math.min(colInfo.topPit, rowIndex);\n\t\t\t// 更新底坑位置\n\t\t\tcolInfo.bottomPit = Math.max(colInfo.bottomPit, rowIndex);\n\t\t\t// 可见砖块总数更新\n\t\t\t--this.tileCount;\n\t\t}\n\t\t// 夯实数组\n\n\t}, {\n\t\tkey: 'tamp',\n\t\tvalue: function tamp() {\n\t\t\t// 空列数 \n\t\t\tvar emptyCol = [];\n\t\t\t// 空列的最小与最大索引\n\t\t\tvar min = this.col,\n\t\t\t    max = -1;\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = this.updatedColSet[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar colIndex = _step.value;\n\n\t\t\t\t\tvar _colInfo2 = this.wall[colIndex];\n\t\t\t\t\tvar start = _colInfo2.start,\n\t\t\t\t\t    end = _colInfo2.end,\n\t\t\t\t\t    pitCount = _colInfo2.pitCount,\n\t\t\t\t\t    topPit = _colInfo2.topPit,\n\t\t\t\t\t    bottomPit = _colInfo2.bottomPit,\n\t\t\t\t\t    count = _colInfo2.count;\n\n\t\t\t\t\t// 垂直方法压缩 \n\n\t\t\t\t\tif (pitCount > 0) {\n\t\t\t\t\t\t// 连续空洞\n\t\t\t\t\t\tif (bottomPit - topPit + 1 === pitCount) {\n\t\t\t\t\t\t\t// topPit 上面有砖块(如果上面没有砖块就已经是压缩状态)\n\t\t\t\t\t\t\tif (topPit > start) {\n\t\t\t\t\t\t\t\t// 起始索引，其实是顶坑索引的正上方\n\t\t\t\t\t\t\t\tvar fromIndex = (topPit - 1) * this.col + colIndex;\n\t\t\t\t\t\t\t\t// 目标索引\n\t\t\t\t\t\t\t\tvar toIndex = start * this.col + colIndex;\n\t\t\t\t\t\t\t\t// 底坑索引 - 在夯实过程中会变\n\t\t\t\t\t\t\t\tvar bottomPitIndex = bottomPit * this.col + colIndex;\n\t\t\t\t\t\t\t\tfor (var _i3 = fromIndex; _i3 >= toIndex; _i3 -= this.col, bottomPitIndex -= this.col) {\n\t\t\t\t\t\t\t\t\t// 执行压缩\n\t\t\t\t\t\t\t\t\tvar _tile2 = this.grid[bottomPitIndex] = this.grid[_i3];\n\t\t\t\t\t\t\t\t\tdelete this.grid[_i3];\n\t\t\t\t\t\t\t\t\t// 更新自身索引\n\t\t\t\t\t\t\t\t\t_tile2.index = bottomPitIndex;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 非连续空洞\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// 底坑索引 - 在夯实过程中会变\n\t\t\t\t\t\t\t\tvar _bottomPitIndex = bottomPit * this.col + colIndex;\n\t\t\t\t\t\t\t\t// 起始索引 - 底坑索引的正上方\t\n\t\t\t\t\t\t\t\tvar _fromIndex = _bottomPitIndex - this.col;\n\t\t\t\t\t\t\t\t// 目标索引 \n\t\t\t\t\t\t\t\tvar _toIndex = start * this.col + colIndex;\n\t\t\t\t\t\t\t\tfor (var _i4 = _fromIndex; _i4 >= _toIndex; _i4 -= this.col) {\n\t\t\t\t\t\t\t\t\tvar _tile3 = this.grid[_i4];\n\t\t\t\t\t\t\t\t\t// 当前位置有砖块，执行压缩\n\t\t\t\t\t\t\t\t\tif (_tile3 !== undefined) {\n\t\t\t\t\t\t\t\t\t\t// 执行压缩\n\t\t\t\t\t\t\t\t\t\tthis.grid[_bottomPitIndex] = _tile3;\n\t\t\t\t\t\t\t\t\t\tdelete this.grid[_i4];\n\t\t\t\t\t\t\t\t\t\t// 更新自身索引\n\t\t\t\t\t\t\t\t\t\t_tile3.index = _bottomPitIndex;\n\t\t\t\t\t\t\t\t\t\t// 底坑索引上升\n\t\t\t\t\t\t\t\t\t\t_bottomPitIndex -= this.col;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// 更新当前列的顶部行索引\n\t\t\t\t\t_colInfo2.start += pitCount;\n\t\t\t\t\t// 当前列不存在色砖\n\t\t\t\t\tif (_colInfo2.count === 0) {\n\t\t\t\t\t\t// 空列数\n\t\t\t\t\t\temptyCol.push(colIndex);\n\t\t\t\t\t\t// 动态记录最大最小索引\n\t\t\t\t\t\tmax = Math.max(colIndex, max);\n\t\t\t\t\t\tmin = Math.min(colIndex, min);\n\t\t\t\t\t}\n\t\t\t\t\t// 当前列仍有色砖\n\t\t\t\t\telse {\n\t\t\t\t\t\t\t// 重置坑洞信息\n\t\t\t\t\t\t\t_colInfo2.pitCount = 0;\n\t\t\t\t\t\t\t_colInfo2.topPit = _colInfo2.count;\n\t\t\t\t\t\t\t_colInfo2.bottomPit = -1;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 空列总数\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar emptyColCount = emptyCol.length;\n\t\t\t// 当前列数\n\t\t\tvar colCount = this.wall.length;\n\t\t\t// 有空列，水平方向压缩 \n\t\t\tif (emptyColCount > 0) {\n\t\t\t\t// 连续的空列\n\t\t\t\tif (emptyColCount === 1 || max - min + 1 === emptyColCount) {\n\t\t\t\t\t// 空列不处在最右边 - 空列在最右边表示已经是压缩状态，删除最右边的空列信息\n\t\t\t\t\tif (max !== colCount - 1) {\n\t\t\t\t\t\tfor (var i = max + 1; i < colCount; ++i) {\n\t\t\t\t\t\t\tvar colInfo = this.wall[i];\n\t\t\t\t\t\t\tvar start = colInfo.start,\n\t\t\t\t\t\t\t    end = colInfo.end;\n\t\t\t\t\t\t\t// 压缩\n\n\t\t\t\t\t\t\tfor (var j = start; j <= end; ++j) {\n\t\t\t\t\t\t\t\t// 压缩前索引\n\t\t\t\t\t\t\t\tvar indexA = j * this.col + i;\n\t\t\t\t\t\t\t\t// 压缩后索引 -- 其实就是往左移动 emptyColCoount 行\n\t\t\t\t\t\t\t\tvar indexB = indexA - emptyColCount;\n\t\t\t\t\t\t\t\t// 招行压缩\n\t\t\t\t\t\t\t\tvar tile = this.grid[indexB] = this.grid[indexA];\n\t\t\t\t\t\t\t\tdelete this.grid[indexA];\n\t\t\t\t\t\t\t\t// 更新索引\n\t\t\t\t\t\t\t\ttile.index = indexB;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// wall 信息更新\n\t\t\t\t\t\t\tthis.wall[i - emptyColCount] = colInfo;\n\t\t\t\t\t\t\tdelete this.wall[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 非连续的空列\n\t\t\t\telse {\n\t\t\t\t\t\t// 最左边的空列 - 压缩过程会变化\n\t\t\t\t\t\tvar leftEmptyColIndex = min;\n\t\t\t\t\t\tfor (var _i2 = min + 1; _i2 < colCount; ++_i2) {\n\t\t\t\t\t\t\tvar _colInfo = this.wall[_i2];\n\t\t\t\t\t\t\tvar start = _colInfo.start,\n\t\t\t\t\t\t\t    end = _colInfo.end,\n\t\t\t\t\t\t\t    count = _colInfo.count;\n\t\t\t\t\t\t\t// 当前列到最左边空列的距离\n\n\t\t\t\t\t\t\tvar distance = _i2 - leftEmptyColIndex;\n\t\t\t\t\t\t\t// 非空行 - 压缩\n\t\t\t\t\t\t\tif (count > 0) {\n\t\t\t\t\t\t\t\tfor (var _j = start; _j <= end; ++_j) {\n\t\t\t\t\t\t\t\t\t// 压缩前索引\n\t\t\t\t\t\t\t\t\tvar _indexA = _j * this.col + _i2;\n\t\t\t\t\t\t\t\t\t// 压缩后的索引 -- 其实就是移动到最左边的空列\n\t\t\t\t\t\t\t\t\tvar _indexB = _indexA - distance;\n\t\t\t\t\t\t\t\t\t// 招行压缩\n\t\t\t\t\t\t\t\t\tvar _tile = this.grid[_indexB] = this.grid[_indexA];\n\t\t\t\t\t\t\t\t\tdelete this.grid[_indexA];\n\t\t\t\t\t\t\t\t\t// 更新索引\n\t\t\t\t\t\t\t\t\t_tile.index = _indexB;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// wall 信息更新\n\t\t\t\t\t\t\t\tthis.wall[leftEmptyColIndex] = _colInfo;\n\t\t\t\t\t\t\t\tdelete this.wall[_i2];\n\n\t\t\t\t\t\t\t\t// 最左边的空理右移一列\n\t\t\t\t\t\t\t\t++leftEmptyColIndex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// 删除最右边的空列\n\t\t\t\tthis.wall.splice(colCount - emptyColCount, emptyColCount);\n\t\t\t}\n\n\t\t\t// 清空 updatedColSet\n\t\t\tthis.updatedColSet.clear();\n\t\t}\n\t\t/*\n  \t@ 检查是否死局\n  \t@ 非死局会返回一个索引值\n  \t@ 死局返回 false\n  */\n\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\tif (this.tileCount === 0) return false;\n\t\t\t// 取一个随机「列」样本\n\t\t\tvar patternCol = Math.random() * this.wall.length >> 0;\n\t\t\tvar _wall$patternCol = this.wall[patternCol],\n\t\t\t    start = _wall$patternCol.start,\n\t\t\t    end = _wall$patternCol.end;\n\t\t\t// 取一个随机「行」样式\n\n\t\t\tvar patternRow = Math.random() * (end - start + 1) + start >> 0;\n\n\t\t\t// 向左扫描「列」\n\t\t\tfor (var col = patternCol; col >= 0; --col) {\n\t\t\t\tvar colInfo = this.wall[col];\n\t\t\t\t// 行索引 \n\t\t\t\tvar rowIndex = patternCol === col ? patternRow : colInfo.start;\n\t\t\t\t// 向下扫描「行」\n\t\t\t\tfor (var row = rowIndex; row <= colInfo.end; ++row) {\n\t\t\t\t\tvar index = row * this.col + col;\n\t\t\t\t\t// 有同色砖块，直接中断\n\t\t\t\t\tif (this.hasNeighbour(index, row, col)) {\n\t\t\t\t\t\treturn index;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 向右扫描「列」\n\t\t\tfor (var _col = patternCol, len = this.wall.length; _col < len; ++_col) {\n\t\t\t\tvar _colInfo3 = this.wall[_col];\n\t\t\t\t// 行索引 \n\t\t\t\tvar _rowIndex = patternCol === _col ? patternRow - 1 : _colInfo3.end;\n\t\t\t\t// 向上扫描「行」\n\t\t\t\tfor (var _row = _rowIndex; _row >= _colInfo3.start; --_row) {\n\t\t\t\t\tvar _index = _row * this.col + _col;\n\t\t\t\t\t// 有同色砖块，直接中断\n\t\t\t\t\tif (this.hasNeighbour(_index, _row, _col)) {\n\t\t\t\t\t\treturn _index;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}]);\n\n\treturn Model;\n}();\n\nexports.default = Model;\n\n//# sourceURL=webpack:///./script/core/Model.es6?");

/***/ }),

/***/ "./script/core/View.es6":
/*!******************************!*\
  !*** ./script/core/View.es6 ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(/*! ../lib/pixi.extension */ \"./script/lib/pixi.extension.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar View = function () {\n\tfunction View(view) {\n\t\tvar _this = this;\n\n\t\t_classCallCheck(this, View);\n\n\t\t// 高宽比 \n\t\tvar ratiio = 375 / 603;\n\t\t// 当前高度与 ip6的高度比 \n\t\tvar ip6Ratio = 1;\n\t\t// 更新宽高比 \n\t\tvar updateRatio = function updateRatio() {\n\t\t\t// 浏览器的宽高\n\t\t\tvar cw = document.documentElement.clientWidth,\n\t\t\t    ch = document.documentElement.clientHeight;\n\t\t\t// 横屏\n\t\t\tif (cw > ch) {\n\t\t\t\tvar _ref = [ch, cw];\n\t\t\t\tcw = _ref[0];\n\t\t\t\tch = _ref[1];\n\t\t\t}\n\t\t\tvar curRatio = ch / cw;\n\t\t\tif (curRatio !== ratiio) {\n\t\t\t\tratiio = curRatio;\n\t\t\t\tip6Ratio = ch / 603;\n\t\t\t\t_this.height = _this.width * ratiio;\n\t\t\t\t_this.app && app.renderer.resize(_this.width, _this.height);\n\t\t\t}\n\t\t};\n\t\t// 界面的宽高\n\t\tthis.width = 375;\n\t\tthis.height = 603;\n\t\t// 按当前浏览器适配\n\t\tupdateRatio();\n\t\t// 监听 resize 事件\n\t\twindow.addEventListener(\"resize\", updateRatio);\n\n\t\tvar app = new PIXI.Application({\n\t\t\twidth: this.width,\n\t\t\theight: this.height,\n\t\t\tresolution: 2,\n\t\t\tbackgroundColor: 0x333333,\n\t\t\tview: view\n\t\t});\n\n\t\t// 挂载属性\n\t\tObject.assign(this, app);\n\t\tthis.ticker = app.ticker;\n\n\t\t// 原始砖色\n\t\tthis.originClrs = [\n\t\t// 红色\n\t\t0xe45c5b,\n\t\t// 绿色 \n\t\t0x64df6a,\n\t\t// 蓝色\n\t\t0x3d91e1,\n\t\t// 黄色\n\t\t0xffdf7b,\n\t\t// 紫色\n\t\t0xec3ffc];\n\n\t\t// 砖块数组\n\t\tthis.tiles = new Array(100);\n\n\t\t// 游戏区域\n\t\tthis.area = new PIXI.Container();\n\t\tvar emptySprite = PIXI.Sprite.from(PIXI.Texture.EMPTY);\n\t\temptySprite.set({ width: this.width, height: this.width });\n\t\tthis.area.addChild(emptySprite);\n\t\tthis.area.set({ x: .5, y: this.height - this.width });\n\n\t\t// 砖块尺寸\n\t\tthis.tileSize = 36.5;\n\n\t\t// 表格尺寸\n\t\tthis.gridWidth = 37.5;\n\t\tthis.gridHeight = 37.5;\n\n\t\t// 表格的行列数\n\t\tthis.col = this.row = 10;\n\n\t\t// X轴中心点\n\t\tthis.centerX = this.width / 2;\n\n\t\t// 游戏单独一个容器\n\t\tthis.game = new PIXI.Container();\n\n\t\t// 添加到舞台\n\t\tthis.stage.addChild(this.game);\n\n\t\t// 添加到舞台 \n\t\tthis.game.addChild(this.area);\n\n\t\t// 默认不显示游戏界面\n\t\tthis.hideGame();\n\n\t\t// 添加点击事件\n\t\tthis.area.on(\"ontouchstart\" in document ? \"tap\" : \"click\", function (e) {\n\t\t\t// 暂停不触发事件\n\t\t\tif (_this.paused === true) return;\n\t\t\tvar x = e.data.global.x,\n\t\t\t    y = e.data.global.y - _this.area.y;\n\t\t\tvar col = x / _this.gridWidth >> 0,\n\t\t\t    row = y / _this.gridHeight >> 0;\n\t\t\tvar position = col + row * 10;\n\t\t\t_this.event.dispatch(\"view-tap\", position);\n\t\t});\n\n\t\t// 关卡信息\n\t\tthis.level = new PIXI.Text(\"关卡：0\", {\n\t\t\tfontFamily: \"Arial\",\n\t\t\tfontSize: 16,\n\t\t\tfill: 0xffffff\n\t\t});\n\t\tthis.level.set({ top: 16, left: 16 });\n\n\t\t// 目标分数 \n\t\tthis.goal = new PIXI.Text(\"目标：0\", {\n\t\t\tfontFamily: \"Arial\",\n\t\t\tfontSize: 16,\n\t\t\tfill: 0xffffff,\n\t\t\talign: \"center\"\n\t\t});\n\n\t\tthis.goal.set({\n\t\t\tanchorX: .5,\n\t\t\tanchorY: .5,\n\t\t\tx: this.centerX,\n\t\t\ttop: 25\n\t\t});\n\n\t\t// 当前分数\n\t\tthis.totalLabel = new PIXI.Text(\"0\", {\n\t\t\tfontFamily: \"Arial\",\n\t\t\tfontSize: 24,\n\t\t\tfill: 0xf7f408,\n\t\t\talign: \"center\"\n\t\t});\n\n\t\tthis.totalLabel.set({\n\t\t\tanchorX: .5,\n\t\t\tanchorY: .5,\n\t\t\tx: this.centerX,\n\t\t\ttop: 50\n\t\t});\n\n\t\tReflect.defineProperty(this, \"total\", {\n\t\t\tget: function get() {\n\t\t\t\treturn _this._total || 0;\n\t\t\t},\n\t\t\tset: function set(value) {\n\t\t\t\t_this._total = value;\n\t\t\t\t_this.totalLabel.text = value;\n\t\t\t}\n\t\t});\n\n\t\t// 消除信息\n\t\tthis.cleanInfo = new PIXI.Text(\"\", {\n\t\t\tfontFamily: \"Arial\",\n\t\t\tfontSize: 16,\n\t\t\tfill: 0xffffff,\n\t\t\talign: \"center\"\n\t\t});\n\n\t\tthis.cleanInfo.set({\n\t\t\tanchorX: .5,\n\t\t\tanchorY: .5,\n\t\t\tx: this.centerX,\n\t\t\ttop: 78\n\t\t});\n\n\t\t// 奖励信息 \n\t\tthis.bountyLabel = new PIXI.Text(\"奖励 \", {\n\t\t\tfontFamily: \"Arial\",\n\t\t\tfontSize: 16,\n\t\t\tfill: 0xffffff,\n\t\t\talign: \"center\"\n\t\t});\n\t\tthis.bountyLabel.set({\n\t\t\tanchorX: .5,\n\t\t\tanchorY: .5,\n\t\t\tx: this.centerX,\n\t\t\ttop: 410 * ip6Ratio,\n\t\t\tdefaultTop: 410 * ip6Ratio,\n\t\t\trenderable: false\n\t\t});\n\n\t\t// 默认的奖励分数 \n\t\tthis._bounty = 2000;\n\n\t\tReflect.defineProperty(this, \"bounty\", {\n\t\t\tget: function get() {\n\t\t\t\treturn _this._bounty;\n\t\t\t},\n\t\t\tset: function set(value) {\n\t\t\t\t_this._bounty = value;\n\t\t\t\t_this.bountyLabel.text = \"奖励 \" + value;\n\t\t\t}\n\t\t});\n\n\t\t// 剩余星星信息\n\t\tthis.starInfo = new PIXI.Text(\"\", {\n\t\t\tfontFamily: \"Arial\",\n\t\t\tfontSize: 12,\n\t\t\tfill: 0xffffff,\n\t\t\talign: \"center\"\n\t\t});\n\t\tthis.starInfo.set({\n\t\t\tanchorX: .5,\n\t\t\tanchorY: .5,\n\t\t\tx: this.centerX,\n\t\t\ttop: 435 * ip6Ratio,\n\t\t\trenderable: false\n\t\t});\n\n\t\t// 进入关卡前的屏幕信息\n\t\tthis.levelInfo = new PIXI.Container();\n\t\tthis.levelInfo.title = new PIXI.Text(\"关卡 n\", {\n\t\t\tfontFamily: \"Arial\",\n\t\t\tfontSize: 30,\n\t\t\tfill: 0xffffff,\n\t\t\talign: \"center\"\n\t\t});\n\t\tthis.levelInfo.title.set({\n\t\t\tanchorX: .5,\n\t\t\tanchorY: .5,\n\t\t\tx: this.centerX,\n\t\t\ttop: 260 * ip6Ratio\n\t\t});\n\t\tthis.levelInfo.goal = new PIXI.Text(\"目标分数 xxxx\", {\n\t\t\tfontFamily: \"Arial\",\n\t\t\tfontSize: 14,\n\t\t\tfill: 0xffffff,\n\t\t\talign: \"center\"\n\t\t});\n\n\t\tthis.levelInfo.goal.set({\n\t\t\tanchorX: .5,\n\t\t\tanchorY: .5,\n\t\t\tx: this.centerX,\n\t\t\ttop: 300 * ip6Ratio\n\t\t});\n\n\t\tthis.levelInfo.addChild(this.levelInfo.title, this.levelInfo.goal);\n\n\t\tthis.game.addChild(this.level, this.goal, this.totalLabel, this.cleanInfo, this.bountyLabel, this.starInfo);\n\n\t\t// 生成砖块 Texture\n\t\tthis.generateTileTextures();\n\n\t\t// 生成星星 Texture\n\t\tthis.generateStarTextures();\n\n\t\t// 爆星队列\n\t\tthis.bombList = [];\n\n\t\t// 加载图片\n\t\tPIXI.loader.add([{ name: \"red\", url: \"images/red@2x.png\" }, { name: \"green\", url: \"images/green@2x.png\" }, { name: \"blue\", url: \"images/blue@2x.png\" }, { name: \"yellow\", url: \"images/yellow@2x.png\" }, { name: \"purple\", url: \"images/purple@2x.png\" }, { name: \"star_red\", url: \"images/star_red@2x.png\" }, { name: \"star_green\", url: \"images/star_green@2x.png\" }, { name: \"star_blue\", url: \"images/star_blue@2x.png\" }, { name: \"star_yellow\", url: \"images/star_yellow@2x.png\" }, { name: \"star_purple\", url: \"images/star_purple@2x.png\" }, { name: \"pause\", url: \"images/pause@2x.png\" }, { name: \"play\", url: \"images/play@2x.png\" }, { name: \"cover\", url: \"images/cover.jpg\" }, { name: \"rewards\", url: \"images/rewards.jpg\" }]).load(function () {\n\t\t\t[\"red\", \"green\", \"blue\", \"yellow\", \"purple\"].forEach(function (clr, index) {\n\t\t\t\t_this.tileTextures[index].baseTexture = PIXI.utils.TextureCache[clr].baseTexture;\n\t\t\t\t_this.starTextures[index].baseTexture = PIXI.utils.TextureCache[\"star_\" + clr].baseTexture;\n\t\t\t});\n\t\t\t// 暂停与播放按钮\n\t\t\tvar btn = new PIXI.Sprite(PIXI.utils.TextureCache[\"pause\"]);\n\t\t\tbtn.interactive = true;\n\t\t\tbtn.on(\"ontouchstart\" in document ? \"tap\" : \"click\", function () {\n\t\t\t\tvar name = btn.texture.textureCacheIds[0];\n\t\t\t\t_this.event.dispatch(\"view-press-\" + name);\n\t\t\t});\n\t\t\tbtn.set({ top: 12, left: 325 });\n\t\t\t_this.game.addChild(btn);\n\t\t\t_this.btn = btn;\n\t\t\t// 背景图片 \n\t\t\t_this.stage.addChildAt(new PIXI.Sprite(PIXI.utils.TextureCache[\"cover\"]), 0);\n\t\t});\n\t}\n\n\t// 初始化\n\n\n\t_createClass(View, [{\n\t\tkey: \"init\",\n\t\tvalue: function init() {\n\t\t\tvar _this2 = this;\n\n\t\t\t// 开启 ticker\n\t\t\tthis.ticker.started === false && this.ticker.start();\n\t\t\t// 隐藏奖励信息 \n\t\t\tthis.area.renderable = this.bountyLabel.renderable = this.starInfo.renderable = false;\n\t\t\t// 显示游戏界面\n\t\t\tthis.showGame();\n\t\t\tthis.showLevelInfo().then(function () {\n\t\t\t\t// 开启点击\n\t\t\t\t_this2.area.interactive = true;\n\t\t\t\t// 显示砖块\n\t\t\t\t_this2.area.renderable = true;\n\t\t\t\t// 做下掉的动画\n\t\t\t\tfor (var len = _this2.tiles.length, i = len - 1; i >= 0; --i) {\n\t\t\t\t\tvar tile = _this2.tiles[i];\n\t\t\t\t\tTweenMax.from(tile.sprite, .5, {\n\t\t\t\t\t\ty: \"-=\" + (600 - Math.random() * _this2.gridHeight >> 0),\n\t\t\t\t\t\tdelay: ((len - i) / _this2.col >> 0) * .05,\n\t\t\t\t\t\tease: Linear.easeNone\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.destroy = this.destroy.bind(this);\n\t\t\tthis.showLevelInfo = this.showLevelInfo.bind(this);\n\t\t\tthis.generateTileSprite = this.generateTileSprite.bind(this);\n\t\t\tthis.generateStar = this.generateStar.bind(this);\n\t\t\tthis.updateTileClr = this.updateTileClr.bind(this);\n\t\t\tthis.updateTileIndex = this.updateTileIndex.bind(this);\n\t\t\tthis.generateTileTextures = this.generateTileTextures.bind(this);\n\t\t\tthis.generateStarTextures = this.generateStarTextures.bind(this);\n\t\t\tthis.update = this.update.bind(this);\n\t\t\tthis.bomb = this.bomb.bind(this);\n\t\t\tthis.showTileScore = this.showTileScore.bind(this);\n\t\t\tthis.setCleanInfo = this.setCleanInfo.bind(this);\n\t\t\tthis.setLevel = this.setLevel.bind(this);\n\t\t\tthis.setGoal = this.setGoal.bind(this);\n\t\t\tthis.showBountyInfo = this.showBountyInfo.bind(this);\n\t\t\tthis.hideGame = this.hideGame.bind(this);\n\t\t\tthis.showGame = this.showGame.bind(this);\n\t\t\tthis.pause = this.pause.bind(this);\n\t\t\tthis.resume = this.resume.bind(this);\n\t\t}\n\n\t\t// 销毁\n\n\t}, {\n\t\tkey: \"destroy\",\n\t\tvalue: function destroy() {\n\t\t\tthis.ticker.stop();\n\t\t\t// 清空 timer\n\t\t\tthis.timer.clean();\n\t\t\t// 暂停状态重置\n\t\t\tthis.paused = false;\n\t\t\t// 隐藏游戏界面\n\t\t\tthis.game.renderable = false;\n\t\t\tthis.renderer.render(this.stage);\n\t\t}\n\n\t\t// 显示关卡信息\n\n\t}, {\n\t\tkey: \"showLevelInfo\",\n\t\tvalue: function showLevelInfo() {\n\t\t\tvar _this3 = this;\n\n\t\t\tthis.game.addChild(this.levelInfo);\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t// 显示当前关卡信息 \n\t\t\t\tTweenMax.fromTo(_this3.levelInfo, .6, { x: _this3.width }, { x: 0 });\n\t\t\t\tTweenMax.to(_this3.levelInfo, .6, {\n\t\t\t\t\tx: -_this3.width,\n\t\t\t\t\tdelay: 3,\n\t\t\t\t\tonComplete: function onComplete() {\n\t\t\t\t\t\t_this3.levelInfo.parent.removeChild(_this3.levelInfo);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tTweenMax.fromTo(_this3.levelInfo.goal, .6, { x: _this3.centerX + _this3.width }, { x: _this3.centerX, delay: .6 });\n\t\t\t\tTweenMax.to(_this3.goal, .15, {\n\t\t\t\t\talpha: 0,\n\t\t\t\t\tdelay: 1.2,\n\t\t\t\t\trepeat: 9,\n\t\t\t\t\tyoyo: true,\n\t\t\t\t\tease: Linear.easeNone\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// 生成对应的砖块\n\n\t}, {\n\t\tkey: \"generateTileSprite\",\n\t\tvalue: function generateTileSprite() {\n\t\t\tvar clr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n\t\t\tvar tile = new PIXI.Sprite(this.tileTextures[clr]);\n\t\t\treturn tile;\n\t\t}\n\n\t\t// 生成对应的星星\n\n\t}, {\n\t\tkey: \"generateStar\",\n\t\tvalue: function generateStar() {\n\t\t\tvar clr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n\n\t\t\tvar star = new PIXI.Sprite(this.starTextures[clr % 5]);\n\t\t\treturn star;\n\t\t}\n\n\t\t// 更改砖块的颜色\n\n\t}, {\n\t\tkey: \"updateTileClr\",\n\t\tvalue: function updateTileClr(tile, clr) {\n\t\t\tif (clr === undefined) return;\n\t\t\ttile.sprite.texture = this.tileTextures[clr];\n\t\t\ttile.clr = clr;\n\t\t}\n\n\t\t// 砖块位置变化 \n\n\t}, {\n\t\tkey: \"updateTileIndex\",\n\t\tvalue: function updateTileIndex(tile, index) {\n\t\t\tvar x = index % this.col * this.gridWidth;\n\t\t\tvar y = (index / this.col >> 0) * this.gridHeight;\n\t\t\ttile.index = index;\n\t\t\t// 游戏过程，有动画\n\t\t\tTweenMax.to(tile.sprite, .08, { x: x, y: y, ease: Linear.easeNone });\n\t\t}\n\n\t\t// 生成砖块的 Texture\n\n\t}, {\n\t\tkey: \"generateTileTextures\",\n\t\tvalue: function generateTileTextures() {\n\t\t\tvar _this4 = this;\n\n\t\t\tthis.tileTextures = this.originClrs.map(function (clr) {\n\t\t\t\tvar tile = new PIXI.Graphics().beginFill(clr).drawRoundedRect(0, 0, _this4.tileSize, _this4.tileSize, 6);\n\t\t\t\treturn tile.generateCanvasTexture();\n\t\t\t});\n\t\t}\n\n\t\t// 生成星星的 Texture \n\n\t}, {\n\t\tkey: \"generateStarTextures\",\n\t\tvalue: function generateStarTextures() {\n\t\t\tthis.starTextures = this.originClrs.map(function (clr) {\n\t\t\t\tvar star = new PIXI.Graphics().beginFill(clr).drawPolygon([20, 0, 26.5, 16, 40, 15, 28, 25, 32, 38, 20, 30, 8, 38, 12, 23, 12, 24, 0, 15, 15, 15]);\n\t\t\t\treturn star.generateCanvasTexture();\n\t\t\t});\n\t\t}\n\n\t\t// 更新砖块\n\n\t}, {\n\t\tkey: \"update\",\n\t\tvalue: function update(_ref2) {\n\t\t\tvar originIndex = _ref2.originIndex,\n\t\t\t    index = _ref2.index,\n\t\t\t    clr = _ref2.clr,\n\t\t\t    removed = _ref2.removed,\n\t\t\t    score = _ref2.score;\n\n\t\t\t// 还没有 originIndex 或没有色值，直接不处理\n\t\t\tif (originIndex === undefined || clr === undefined) return;\n\t\t\tvar tile = this.tiles[originIndex];\n\t\t\t// tile 不存在，生成对应砖块\n\t\t\tif (tile === undefined) {\n\t\t\t\tthis.tiles[originIndex] = tile = {\n\t\t\t\t\tsprite: this.generateTileSprite(clr),\n\t\t\t\t\tclr: clr,\n\t\t\t\t\tindex: index,\n\t\t\t\t\tscore: 0,\n\t\t\t\t\toriginIndex: originIndex,\n\t\t\t\t\tremoved: true\n\t\t\t\t};\n\t\t\t\t// 定位\n\t\t\t\tthis.updateTileIndex(tile);\n\t\t\t\t// 添加到舞台\n\t\t\t\tthis.area.addChild(tile.sprite);\n\t\t\t}\n\t\t\t// tile 存在，判断颜色是否一样\n\t\t\telse if (tile.clr !== clr) {\n\t\t\t\t\tthis.updateTileClr(tile, clr);\n\t\t\t\t}\n\n\t\t\t// 当前索引变化 ----- 表示位置也有变化 \n\t\t\tif (tile.index !== index) {\n\t\t\t\tthis.updateTileIndex(tile, index);\n\t\t\t}\n\n\t\t\t// 设置分数\n\t\t\tif (tile.score !== score) {\n\t\t\t\ttile.score = score;\n\t\t\t}\n\n\t\t\tif (tile.removed !== removed) {\n\t\t\t\t// 移除或添加当前节点\n\t\t\t\ttrue === removed ? this.bomb(tile) : this.area.addChild(tile.sprite);\n\t\t\t\ttile.removed = removed;\n\t\t\t}\n\t\t}\n\n\t\t// 消除色砖前的彩花\n\n\t}, {\n\t\tkey: \"bomb\",\n\t\tvalue: function bomb(tile) {\n\t\t\tvar _this5 = this;\n\n\t\t\t// 爆炸锁定\n\t\t\tif (this.bombLock === true) {\n\t\t\t\t// 存入数组\n\t\t\t\tthis.bombList.push(tile);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.bombLock = true;\n\t\t\t// 砖块的位置\n\t\t\tvar index = tile.index,\n\t\t\t    clr = tile.clr,\n\t\t\t    sprite = tile.sprite,\n\t\t\t    _tile$sprite = tile.sprite,\n\t\t\t    x = _tile$sprite.x,\n\t\t\t    y = _tile$sprite.y;\n\t\t\t// 水平方向 1 向左， -1 向右\n\n\t\t\tvar directionX = 1;\n\n\t\t\tvar _loop = function _loop(i, len) {\n\t\t\t\tvar star = _this5.generateStar(clr);\n\t\t\t\t_this5.area.addChild(star);\n\t\t\t\tdirectionX *= -1;\n\t\t\t\t// 统一设置属性 \n\t\t\t\tstar.set({\n\t\t\t\t\torigin: [star.width / 2, star.height / 2],\n\t\t\t\t\ttop: y,\n\t\t\t\t\tleft: x,\n\t\t\t\t\tscaleX: .5,\n\t\t\t\t\tscaleY: .5,\n\t\t\t\t\talpha: .9,\n\t\t\t\t\t// 水平速度 \n\t\t\t\t\tvelocityX: (Math.random() * 10 + 1) * directionX,\n\t\t\t\t\tvelocityY: Math.random() * 10 - 20,\n\t\t\t\t\taccelerationY: Math.random() + 2\n\t\t\t\t});\n\n\t\t\t\t// 喷发星星\n\t\t\t\tTweenMax.to(star, 1.5, {\n\t\t\t\t\tscaleX: .15,\n\t\t\t\t\tscaleY: .15,\n\t\t\t\t\talpha: .1,\n\t\t\t\t\ttime: .6,\n\t\t\t\t\tease: Linear.easeNone,\n\t\t\t\t\tonComplete: function onComplete() {\n\t\t\t\t\t\treturn star.destroy();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tfor (var i = 0, len = 12; i <= len; ++i) {\n\t\t\t\t_loop(i, len);\n\t\t\t}\n\n\t\t\t// 爆下一个砖块的函数 \n\t\t\tvar bombNextTile = function bombNextTile() {\n\t\t\t\tvar nextTile = _this5.bombList.shift();\n\t\t\t\t// 解除锁定 \n\t\t\t\t_this5.bombLock = false;\n\t\t\t\t// 删除当前砖块\n\t\t\t\tsprite.parent.removeChild(sprite);\n\t\t\t\tif (nextTile !== undefined) {\n\t\t\t\t\t_this5.bomb(nextTile);\n\t\t\t\t}\n\t\t\t\t// 没砖块了 \n\t\t\t\telse {\n\t\t\t\t\t\t// 游戏过程\n\t\t\t\t\t\tif (tile.score > 0) {\n\t\t\t\t\t\t\t_this5.event.dispatch(\"view-clean\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 游戏结束\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// 奖励分数不为0，奖励文案上提\n\t\t\t\t\t\t\t\tif (_this5.bounty > 0) {\n\t\t\t\t\t\t\t\t\t// 将分数均分十份\n\t\t\t\t\t\t\t\t\tvar bountyStep = _this5.bounty / 10;\n\t\t\t\t\t\t\t\t\tTweenMax.to(_this5.bountyLabel, .6, {\n\t\t\t\t\t\t\t\t\t\ttop: 80,\n\t\t\t\t\t\t\t\t\t\tonComplete: function onComplete() {\n\t\t\t\t\t\t\t\t\t\t\t_this5.timer.setInterval(function () {\n\t\t\t\t\t\t\t\t\t\t\t\t_this5.total += bountyStep;\n\t\t\t\t\t\t\t\t\t\t\t\t_this5.bounty -= bountyStep;\n\t\t\t\t\t\t\t\t\t\t\t\tif (_this5.bounty === 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t_this5.timer.delete(\"bounty\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t_this5.timer.setTimeout(function () {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn _this5.event.dispatch(\"view-clean-all\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t}, 1400);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}, 80, \"bounty\");\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// 奖励分数为0，直接结束\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t_this5.timer.setTimeout(function () {\n\t\t\t\t\t\t\t\t\t\t\treturn _this5.event.dispatch(\"view-clean-all\");\n\t\t\t\t\t\t\t\t\t\t}, 1400);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t};\n\n\t\t\t// 得分\n\t\t\tif (tile.score > 0) {\n\t\t\t\tthis.showTileScore(tile);\n\t\t\t}\n\t\t\t// 扣除奖励\n\t\t\telse {\n\t\t\t\t\tif (this.bounty > 0) {\n\t\t\t\t\t\tthis.bounty += tile.score;\n\t\t\t\t\t}\n\t\t\t\t\t// 没有奖励分数后，真接全爆\n\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn bombNextTile();\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// 爆下一个砖块\n\t\t\tthis.timer.setTimeout(bombNextTile, 120);\n\t\t}\n\n\t\t// 显示色砖分数\n\n\t}, {\n\t\tkey: \"showTileScore\",\n\t\tvalue: function showTileScore(tile) {\n\t\t\tvar _this6 = this;\n\n\t\t\tvar score = new PIXI.Text(tile.score, {\n\t\t\t\tfontFamily: \"Arial\",\n\t\t\t\tfontSize: 32,\n\t\t\t\tfill: 0xffffff,\n\t\t\t\talign: \"center\"\n\t\t\t});\n\t\t\tscore.set({\n\t\t\t\tanchorX: .5,\n\t\t\t\tanchorY: .5,\n\t\t\t\tx: tile.sprite.x,\n\t\t\t\ty: tile.sprite.y\n\t\t\t});\n\t\t\tTweenMax.to(score, .4, {\n\t\t\t\tx: this.centerX,\n\t\t\t\ty: 603 - this.height - 158,\n\t\t\t\tscaleX: .5,\n\t\t\t\tscaleY: .5,\n\t\t\t\tease: Linear.easeNone,\n\t\t\t\tonComplete: function onComplete() {\n\t\t\t\t\tscore.parent.removeChild(score);\n\t\t\t\t\t_this6.total += tile.score;\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.area.addChild(score);\n\t\t}\n\n\t\t// 显示连消信息\n\n\t}, {\n\t\tkey: \"setCleanInfo\",\n\t\tvalue: function setCleanInfo(count) {\n\t\t\tthis.cleanInfo.tween && this.cleanInfo.tween.kill();\n\t\t\tthis.cleanInfo.text = count + \"\\u8FDE\\u6D88 \" + count * count * 5 + \"\\u5206\";\n\t\t\tthis.cleanInfo.tween = TweenMax.fromTo(this.cleanInfo, .3, {\n\t\t\t\talpha: 0\n\t\t\t}, {\n\t\t\t\talpha: 1,\n\t\t\t\trepeat: 1,\n\t\t\t\tyoyo: true,\n\t\t\t\trepeatDelay: 1\n\t\t\t});\n\t\t}\n\n\t\t// 当前关卡的文案 \n\n\t}, {\n\t\tkey: \"setLevel\",\n\t\tvalue: function setLevel(level) {\n\t\t\tthis.level.text = \"关卡：\" + level;\n\t\t\tthis.levelInfo.title.text = \"关卡\" + level;\n\t\t}\n\n\t\t// 当前目标分数\n\n\t}, {\n\t\tkey: \"setGoal\",\n\t\tvalue: function setGoal(goal) {\n\t\t\tthis.goal.text = \"目标：\" + goal;\n\t\t\tthis.levelInfo.goal.text = \"目标分数 \" + goal;\n\t\t}\n\n\t\t// 显示奖励功能\n\n\t}, {\n\t\tkey: \"showBountyInfo\",\n\t\tvalue: function showBountyInfo(count) {\n\t\t\tvar _this7 = this;\n\n\t\t\tthis.bountyLabel.renderable = this.starInfo.renderable = true;\n\t\t\tthis.starInfo.text = \"\\u5269\\u4F59 \" + count + \" \\u4E2A\\u661F\\u661F\";\n\t\t\t// 初始化奖励分数\n\t\t\tthis.bounty = 2000;\n\t\t\t// 位置重置\n\t\t\tthis.bountyLabel.top = this.bountyLabel.defaultTop;\n\t\t\t// area 闪一闪\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tTweenMax.fromTo(_this7.area, .1, {\n\t\t\t\t\talpha: 1\n\t\t\t\t}, {\n\t\t\t\t\talpha: 0,\n\t\t\t\t\tyoyo: true,\n\t\t\t\t\trepeat: 7,\n\t\t\t\t\tease: Linear.easeNone,\n\t\t\t\t\tonComplete: function onComplete() {\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// 不显示游戏界面\n\n\t}, {\n\t\tkey: \"hideGame\",\n\t\tvalue: function hideGame() {\n\t\t\tthis.game.renderable = false;\n\t\t}\n\n\t\t// 显示游戏界面\n\n\t}, {\n\t\tkey: \"showGame\",\n\t\tvalue: function showGame() {\n\t\t\tthis.game.renderable = true;\n\t\t}\n\n\t\t// 暂停渲染\n\n\t}, {\n\t\tkey: \"pause\",\n\t\tvalue: function pause() {\n\t\t\t// this.stop(); \n\t\t\tTweenMax.pauseAll();\n\t\t\tthis.paused = true;\n\t\t\tthis.btn.texture = PIXI.utils.TextureCache[\"play\"];\n\t\t}\n\t\t// 恢复渲染 \n\n\t}, {\n\t\tkey: \"resume\",\n\t\tvalue: function resume() {\n\t\t\t// this.start(); \n\t\t\tTweenMax.resumeAll();\n\t\t\tthis.paused = false;\n\t\t\tthis.btn.texture = PIXI.utils.TextureCache[\"pause\"];\n\t\t}\n\t}, {\n\t\tkey: \"showReardsBackground\",\n\t\tvalue: function showReardsBackground() {\n\t\t\tthis.stage.removeChildAt(0);\n\t\t\tthis.stage.addChildAt(new PIXI.Sprite(PIXI.utils.TextureCache[\"rewards\"]), 0);\n\t\t}\n\t}]);\n\n\treturn View;\n}();\n\nexports.default = View;\n\n//# sourceURL=webpack:///./script/core/View.es6?");

/***/ }),

/***/ "./script/lib/Event.es6":
/*!******************************!*\
  !*** ./script/lib/Event.es6 ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\n\t@ author: leeenx\n\t@ 事件封装\n\t@ object.on(event, fn) // 监听一个事件\n\t@ object.off(event, fn) // 取消监听\n\t@ object.once(event, fn) // 只监听一次事件\n\t@ object.dispacth(event, arg) // 触发一个事件\n*/\n\nvar Events = function () {\n    function Events() {\n        _classCallCheck(this, Events);\n\n        // 定义的事件与回调\n        this.defineEvent = {};\n    }\n    // 注册事件\n\n\n    _createClass(Events, [{\n        key: \"register\",\n        value: function register(event, cb) {\n            if (!this.defineEvent[event]) {\n                this.defineEvent[event] = [cb];\n            } else {\n                this.defineEvent[event].push(cb);\n            }\n        }\n        // 派遣事件\n\n    }, {\n        key: \"dispatch\",\n        value: function dispatch(event, arg) {\n            if (this.defineEvent[event]) {\n                {\n                    for (var i = 0, len = this.defineEvent[event].length; i < len; ++i) {\n                        this.defineEvent[event][i] && this.defineEvent[event][i](arg);\n                    }\n                }\n            }\n        }\n        // on 监听\n\n    }, {\n        key: \"on\",\n        value: function on(event, cb) {\n            return this.register(event, cb);\n        }\n        // off 方法\n\n    }, {\n        key: \"off\",\n        value: function off(event, cb) {\n            var _this = this;\n\n            if (this.defineEvent[event]) {\n                if (typeof cb == \"undefined\") {\n                    delete this.defineEvent[event]; // 表示全部删除 \n                } else {\n                    var _loop = function _loop(i, len) {\n                        if (cb == _this.defineEvent[event][i]) {\n                            _this.defineEvent[event][i] = null; // 标记为空 - 防止dispath 长度变化 \n                            // 延时删除对应事件\n                            setTimeout(function () {\n                                return _this.defineEvent[event].splice(i, 1);\n                            }, 0);\n                            return \"break\";\n                        }\n                    };\n\n                    // 遍历查找 \n                    for (var i = 0, len = this.defineEvent[event].length; i < len; ++i) {\n                        var _ret = _loop(i, len);\n\n                        if (_ret === \"break\") break;\n                    }\n                }\n            }\n        }\n\n        // once 方法，监听一次\n\n    }, {\n        key: \"once\",\n        value: function once(event, cb) {\n            var _this2 = this;\n\n            var onceCb = function onceCb() {\n                cb && cb();\n                _this2.off(event, onceCb);\n            };\n            this.register(event, onceCb);\n        }\n    }]);\n\n    return Events;\n}();\n\nexports.default = Events;\n\n//# sourceURL=webpack:///./script/lib/Event.es6?");

/***/ }),

/***/ "./script/lib/pixi.extension.js":
/*!**************************************!*\
  !*** ./script/lib/pixi.extension.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// 扩展\n// DisplayObject 的原型\nvar proto = PIXI.DisplayObject.prototype; \nproto.set = function(arg) {\n\tfor(let key in arg) {\n\t\tthis[key] = arg[key]; \n\t}\n}\n\nObject.defineProperties(proto, {\n\tscaleX: {\n\t\tset: function(value) {\n\t\t\tthis.scale.x = value; \n\t\t}, \n\t\tget: function() {\n\t\t\treturn this.scale.x; \n\t\t}\n\t}, \n\tscaleY: {\n\t\tset: function(value) {\n\t\t\tthis.scale.y = value; \n\t\t}, \n\t\tget: function() {\n\t\t\treturn this.scale.y; \n\t\t}\n\t}, \n\tpivotX: {\n\t\tset: function(value) {\n\t\t\tthis.pivot.x = value; \n\t\t}, \n\t\tget: function() {\n\t\t\treturn this.pivot.x; \n\t\t}\n\t}, \n\tpivotY: {\n\t\tset: function(value) {\n\t\t\tthis.pivot.y = value\n\t\t}, \n\t\tget: function() {\n\t\t\treturn this.pivot.y; \n\t\t}\n\t}, \n\tanchorX: {\n\t\tset: function(value) {\n\t\t\tthis.anchor.x = value; \n\t\t}, \n\t\tget: function() {\n\t\t\treturn this.anchor.x; \n\t\t}\n\t}, \n\tanchorY: {\n\t\tset: function(value) {\n\t\t\tthis.anchor.y = value\n\t\t}, \n\t\tget: function() {\n\t\t\treturn this.anchor.y; \n\t\t}\n\t}, \n\torigin: {\n\t\tget: function() { \n\t\t\treturn [this.pivot.x, this.pivot.y]; \n\t\t}, \n\t\tset: function(coord) { \n\t\t\tthis.pivot.set(coord[0], coord[1]); \n\t\t\tthis.updatePosition(); \n\t\t}\n\t}, \n\tleft: { \n\t\tget: function() {\n\t\t\treturn this._left === undefined ? this.x - this.pivot.x : this._left; \n\t\t}, \n\t\tset: function(value) {\n\t\t\tthis._left = value; \n\t\t\tthis.x = value + this.pivot.x; \n\t\t}\n\t}, \n\tright: {\n\t\tget: function() {\n\t\t\treturn this._right === undefined ? this._right : this.x - this.pivot.x; \n\t\t}, \n\t\tset: function(value) { \n\t\t\tif(value === undefined) return ; \n\t\t\tthis._right = value; \n\t\t\tif(this.parent !== null) { \n\t\t\t\tthis.x = this.parent.width - this.width - value; \n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.x = 0; \n\t\t\t} \n\t\t}\n\t}, \n\ttop: { \n\t\tget: function() {\n\t\t\treturn this._top === undefined ? this.y - this.pivot.y : this._top; \n\t\t}, \n\t\tset: function(value) {\n\t\t\tthis._top = value; \n\t\t\tthis.y = value + this.pivot.y; \n\t\t}\n\t}, \n\tbottom: {\n\t\tget: function() {\n\t\t\treturn this._bottom === undefined ? this._bottom : this.y - this.pivot.y; \n\t\t}, \n\t\tset: function(value) { \n\t\t\tif(value === undefined) return ; \n\t\t\tthis._bottom = value; \n\t\t\tif(this.parent !== null) {\n\t\t\t\tthis.y = this.parent.height - this.height - value; \n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.y = 0; \n\t\t\t} \n\t\t}\n\t}, \n\t// 运动时间\n\ttime: {\n\t\tset: function(t) { \n\t\t\tlet elapsed = t - this._t || t; \n\t\t\tthis._t = t; \n\t\t\tlet {velocityX, velocityY, accelerationX, accelerationY} = this; \n\t\t\t// 当前速度 \n\t\t\tthis.velocityX += elapsed * accelerationX; \n\t\t\tthis.velocityY += elapsed * accelerationY; \n\t\t\t// 当前位置\n\t\t\tthis.x += (this.velocityX + velocityX) * elapsed / 2; \n\t\t\tthis.y += (this.velocityY + velocityY) * elapsed / 2; \n\t\t}, \n\t\tget: function() {return this._t}\n\t}\n}); \n\n// 为原型添加速度与加速度属性等\nObject.assign(\n\tproto, \n\t{\n\t\tvelocityX: 0, \n\t\tvelocityY: 0, \n\t\taccelerationX: 0, \n\t\taccelerationY: 0, \n\t\t_top: 0, \n\t\t_left: 0\n\t}\n); \n\n// 更新 position\nproto.updatePosition = function() { \n\tthis.top = this._top; \n\tthis.right = this._right; \n\tthis.bottom = this._bottom; \n\tthis.left = this._left; \n}\n\n// 监听 addChild\nvar _addChild = PIXI.Container.prototype.addChild; \nPIXI.Container.prototype.addChild = function() { \n\tvar len = arguments.length; \n\tif(len === 0) return ;\n\t_addChild.apply(this, arguments); \n\t// 更新 right & bottom\n\tfor(var i = 0; i < len; ++i) { \n\t\tvar child = arguments[i]; \n\t\tchild.right = child._right; \n\t\tchild.bottom = child._bottom; \n\t}\n}\nvar _addChildAt = PIXI.Container.prototype.addChildAt; \nPIXI.Container.prototype.addChildAt = function(child, index) {\n\t_addChildAt.call(this, child, index); \n\t// 更新 right & bottom\n\tchild.right = child._right; \n\tchild.bottom = child._bottom; \n}\n\n//# sourceURL=webpack:///./script/lib/pixi.extension.js?");

/***/ }),

/***/ "./script/lib/shuffle.es6":
/*!********************************!*\
  !*** ./script/lib/shuffle.es6 ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = shuffle;\n/*\n  @ Fisher–Yates（费雪耶兹算法）\n*/\n\nfunction shuffle(a) {\n    for (var i = a.length; i; i--) {\n        var j = Math.floor(Math.random() * i);\n        var _ref = [a[j], a[i - 1]];\n        a[i - 1] = _ref[0];\n        a[j] = _ref[1];\n    }\n    return a;\n}\n\n//# sourceURL=webpack:///./script/lib/shuffle.es6?");

/***/ }),

/***/ "./script/lib/timer.es6":
/*!******************************!*\
  !*** ./script/lib/timer.es6 ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\n    author: leeenx\n    @ timer 对象\n    @ 提供 7 个API如下：\n    @ timer.setTimeout(fun, delay[, id])\n    @ timer.clearTimeout(id)\n    @ timer.setInterval(fun, delay[, id])\n    @ timer.clearInterval(id)\n    @ timer.delete(id) 删除对应id的timeout/interval\n    @ timer.pause(id) 暂停对应id的timeout/interval\n    @ timer.resume(id) 恢复对应id的timeout/interval\n    @ timer.clean() 清空所有 timeout & interval\n*/\n\nvar Timer = function () {\n    // 构造函数 \n    function Timer() {\n        _classCallCheck(this, Timer);\n\n        // 暂停状态 - 这是个公共状态，由外部 Ticker 决定。\n        this.paused = true;\n\n        // 队列\n        this.queue = new Map();\n\n        // 正在使用 timer 的 RAF\n        this.usingRAF = false;\n\n        // useRAF 触发器\n        Reflect.defineProperty(this, \"useRAF\", {\n            set: function set(value) {\n                Reflect.set(this, \"usingRAF\", value);\n                value ? Timer.RAF.enable() : Timer.RAF.disable();\n            }\n        });\n    }\n\n    // setTimeout 的实现\n\n\n    _createClass(Timer, [{\n        key: \"setTimeout\",\n        value: function setTimeout(fn, delay) {\n            var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Symbol(\"timeoutID\");\n\n            // 存入队列 \n            this.queue.set(id, {\n                fn: fn,\n                type: 0,\n                paused: 0,\n                elapsed: 0,\n                delay: delay\n            });\n            return id;\n        }\n\n        // clearTimeout\n\n    }, {\n        key: \"clearTimeout\",\n        value: function clearTimeout(id) {\n            return this.delete(id);\n        }\n\n        // setInterval 的实现\n\n    }, {\n        key: \"setInterval\",\n        value: function setInterval(fn, delay) {\n            var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Symbol(\"intervalID\");\n\n            // 存入队列\n            this.queue.set(id, {\n                fn: fn,\n                type: 1,\n                paused: 0,\n                elapsed: 0,\n                delay: delay\n            });\n            return id;\n        }\n\n        // clearInterval\n\n    }, {\n        key: \"clearInterval\",\n        value: function clearInterval(id) {\n            return this.delete(id);\n        }\n\n        // 修改指定id的 delay/fn\n\n    }, {\n        key: \"set\",\n        value: function set(id) {\n            var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            var item = this.queue.get(id) || {};\n            for (var key in config) {\n                item[key] = config[key];\n            }\n            return true;\n        }\n\n        // 删除 queue 上的成员\n\n    }, {\n        key: \"delete\",\n        value: function _delete(id) {\n            return this.queue.delete(id);\n        }\n\n        // 暂停指定id\n\n    }, {\n        key: \"pause\",\n        value: function pause(id) {\n            id === undefined ? this.pauseAll() : this.queue.get(id).paused = 1;\n            return true;\n        }\n\n        // 恢复指定id\n\n    }, {\n        key: \"resume\",\n        value: function resume(id) {\n            return this.play(id);\n        }\n\n        // 播放指定id\n\n    }, {\n        key: \"play\",\n        value: function play(id) {\n            id === undefined ? this.playAll() : this.queue.get(id).paused = 0;\n            return true;\n        }\n\n        // 清空timer\n\n    }, {\n        key: \"clean\",\n        value: function clean() {\n            this.queue = new Map();\n            return true;\n        }\n\n        // 暂停全部 id\n\n    }, {\n        key: \"pauseAll\",\n        value: function pauseAll() {\n            this.queue.forEach(function (item) {\n                return item.paused = 1;\n            });\n            return true;\n        }\n\n        // 播放全部 id\n\n    }, {\n        key: \"playAll\",\n        value: function playAll() {\n            this.queue.forEach(function (item) {\n                return item.paused = 0;\n            });\n            return true;\n        }\n\n        // tick\n\n    }, {\n        key: \"tick\",\n        value: function tick(delta) {\n            this.paused || this.updateQueue(delta);\n        }\n\n        // 更新 map 队列\n\n    }, {\n        key: \"updateQueue\",\n        value: function updateQueue(delta) {\n            var _this = this;\n\n            this.queue.forEach(function (item, id) {\n                if (item.paused === 1) return;\n                item.elapsed += delta;\n                if (item.elapsed >= item.delay) {\n                    item.fn();\n                    item.type === 0 ? _this.delete(id) : item.elapsed = 0;\n                }\n            });\n        }\n\n        // 状态更新\n\n    }, {\n        key: \"update\",\n        value: function update() {\n            var _this2 = this;\n\n            // 第一次调用 update 时主动停用原生接口\n            this.useRAF = false;\n\n            // 下面是真正的 update\n            this.update = function (delta) {\n                if (_this2.usingRAF) return;\n                _this2.tick(delta);\n            };\n        }\n    }]);\n\n    return Timer;\n}();\n\nvar AnimationFrame = function () {\n    function AnimationFrame() {\n        _classCallCheck(this, AnimationFrame);\n\n        this.time = 0;\n        this.auto = this.auto.bind(this);\n    }\n\n    _createClass(AnimationFrame, [{\n        key: \"auto\",\n        value: function auto(elapsed) {\n            timer.tick(elapsed - this.time);\n            this.time = elapsed;\n            this.id = requestAnimationFrame(this.auto);\n        }\n    }, {\n        key: \"enable\",\n        value: function enable() {\n            timer.paused = false;\n            this.id = requestAnimationFrame(this.auto);\n        }\n    }, {\n        key: \"disable\",\n        value: function disable() {\n            cancelAnimationFrame(this.id);\n        }\n    }]);\n\n    return AnimationFrame;\n}();\n\n// 原生RAF\n\n\nTimer.RAF = new AnimationFrame();\n\n// 对外接口\nvar timer = new Timer();\n\n// 默认使用原生 RAF\ntimer.useRAF = true;\n// 导出timer\nexports.default = timer;\n\n//# sourceURL=webpack:///./script/lib/timer.es6?");

/***/ }),

/***/ "./script/lib/waveaverage.es6":
/*!************************************!*\
  !*** ./script/lib/waveaverage.es6 ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = waveaverage;\n// 快速波动均分算法\nfunction waveaverage() {\n\tvar n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n\tvar crest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n\tvar trough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n\tvar isInteger = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n\t// 平均结果\n\tvar list = [];\n\t// 无法进行波动均分，直接返回完全平分\n\tif (crest > (n - 1) * trough || trough > (n - 1) * crest) {\n\t\treturn new Array(n).fill(0);\n\t}\n\t// 最少需要消除的高度\n\tvar base = 0;\n\t// 波动量\n\tvar wave = 0;\n\t// 高位\n\tvar high = crest;\n\t// 低位\n\tvar low = -trough;\n\t// 累计量 \n\tvar sum = 0;\n\t// 剩余数量 \n\tvar count = n;\n\n\twhile (--count >= 0) {\n\t\t// 获取当前的波动量\n\t\tif (crest > count * trough - sum) {\n\t\t\thigh = count * trough - sum;\n\t\t}\n\t\tif (trough > count * crest + sum) {\n\t\t\tlow = -sum - count * crest;\n\t\t}\n\t\tbase = low;\n\t\twave = high - low;\n\t\t// 随机波动量 \n\t\tvar rnd = void 0;\n\t\tif (count > 0) {\n\t\t\t// 随机波动\n\t\t\trnd = base + Math.random() * (wave + 1);\n\t\t} else {\n\t\t\trnd = -sum;\n\t\t}\n\t\tif (isInteger === true) {\n\t\t\trnd = Math.floor(rnd);\n\t\t}\n\t\tsum += rnd;\n\t\tlist.push(rnd);\n\t}\n\treturn list;\n}\n\n//# sourceURL=webpack:///./script/lib/waveaverage.es6?");

/***/ }),

/***/ 0:
/*!**********************************!*\
  !*** multi ./script/Popstar.es6 ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./script/Popstar.es6 */\"./script/Popstar.es6\");\n\n\n//# sourceURL=webpack:///multi_./script/Popstar.es6?");

/***/ })

/******/ });